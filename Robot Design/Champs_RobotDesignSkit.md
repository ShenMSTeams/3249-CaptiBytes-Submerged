**Did u find itThe Robot Design Skit /// Time is currently our most concerning problem. We should try to cut this down a bit. \-colin**   
**PLEASE DON’T SPEND TIME CHANGING THE SLIDE NUMBERS because they will change….do this last.** 

- **Jacob will have the poster board**

         	     **\-Anthony responsible for bin of robots and attachments**

- **Matthew will be changing slides**


**NOTE: Make sure you are not standing in front of the screen where the slides are being projected.**

**SWAP HATS**

**\[slide 1 AND 2 Eli\]**  
**The welcome/intro slide** 

**Swara**, walk up and put the engineering design notebook and binder in front of the judges. For the binder, point out the robot design sections.

**\[Slide 2-3\]**  **Eli** \- We start our presentation with a timeline of our season which started back in August.  

**\[slide 4 Panchami\]**

**Panchami**: Meet our robot Gary. It's new and improved. We use the Engineering Design Process to design and code our bots to complete as many missions a6s possible on this year’s FLL Submerged robot game\!  
   
**\[slide 5 Swara\]**

*\[Panchami will be holding one of the bots and pointing to the different motors while Swara speaks\]* 

**Swara:** Our robot design uses a spike prime hub and has the most advanced hardware , featuring 

- 2 medium motors and gears for attachments,   
- 2 medium movement motors,   
- 2 small black treadless wheels in the front for balance.  
- 2 light sensors for line squaring,  
- 1 internal motion sensor (known as the gyro) for better reliability  
- 2 wheels with tread for better control  
- A flat frame makes it easy to align onto the walls of the field and in base.  
- Bevel gears attached to motors for drop in attachments. Bevel gears are attached to larger gears giving more torque.  
- AND we coded our missions in python                                                   

**Eli (holding his own bot, puts the** **Kriller onto the bot):** Due to the robot’s universal interface, attachments can be fit onto the front of   
the robot so that they can easily use bevel gears attached to 2 small motors. Here is an example of the interface. We have an attachment called Kriller……  

AFTER the Kriller movement Colin will add…

**Colin:** Eli, that’s a cool attachment but there here one that has both passive and motorized components. We  call it the Crab Hook and use it to do the Artificial Habitat and to release the trident.

***Eli fits an attachment on the robot to present the robot’s attachment interface to the judges***

**\[slide 6 Griffin\]**  
**Griffin:**  First A PICK chart was used to identify missions based on point value, and difficulty.  PICK stands for Possible, Implement, Challenge, or Kill.  We used this data to group our missions for team members to work on and to design  attachments.

**\[slide 7 Eli/Jacob\]**

**Eli:** A robot path diagram was used to group missions to maximize points and time on the field. \[point to image\]

**Jacob:** Pseudocode was used to help plan and code for missions. Here are two examples for missions out of the bases. The red base targets the missions close, as does the blue base.  
   
**\[slide 8 Eli\] Join meeting.**  
**Eli:** For this attachment, motors are used to capture the scuba diver, and a passive attachment is used release the shark.

 I  
**\[slide 9 Anthony\]**  
**Anthony:** The team grouped the missions into color runs. Everyone split up into groups to complete these runs. Here is a list of all our missions \[point to the map\]. Our coded missions add up to 430 points.

**\[slide 10 Anthony\]**

**Anthony:** We improved over the season. At the first rumble our score was 155\. Unfortunately, we had problems with consistency at our qualifier and our score on the table went down. After making changes to our code, attachments, and launch strategy we have coded missions totaling 430 points and are likely to come in around 330 on the table in 2.5 minutes. 

**Arsh:**  Will explain the iterations between the qualifier and champs.After the Qualifier we realized that the blue wheels were affecting our mission runs. After some test we concluded that the thicker black wheels were better suited for runs.

**Griffin:**  Amazing\! However, nothing can work without learning the software\! Here we have two of our programmers to discuss more on the topic.

**\[slide 11\]**

**Jacob**: Here is our mission code for all our runs. It’s in python. As you can see the first program is what we call our Red Run which includes coral nursery, shark, coral reef, and scuba diver. 

**Jacob:** ***\*hands code to each of the judges\**** **\[3 copies\]**

**Colin:**   On the first few pages of the code you have \[Jacob handed to you\], you’ll find our library of tested code. There are different commands such as a simple forward move and a turn or more complex things such as attachment motors or light sensors. It also features settings for gyro/accelerometer assisted movement, which can help the bot navigate the field more accurately. 

**\[slide 12\]**  
**Arsh**: Wow, the mission code looks really complex but I really like the idea of a library to make coding easier for everyone\!

**Colin:**  Another thing, \****Talk about the very unique way we load our library here\****

**\[slide 13 Eli\]**  
**Eli:** We track changes and changes for missions through a spreadsheet. We capture changes, game runs, and notes in our Robot Design notebook at the end of every meeting. We share our code on a shared Google Drive so that everybody on the team can easily access and debug in-development code.  *\[Recommend Swara or someone making sure the judges see this book AND the book that has meeting minutes.\]*

**\[slide 14 Anthony\]**

**Anthony: ** One of our team members created instructions in Bricklink by reverse engineering last year’s bot. This made it possible for the newer members to understand its design. These instructions are shared on Bricklink and were used by a newer Shen team to design their team bot. We made additional changes after our qualifier such as changing the type of wheels and adding pieces for balance.

**\[slide 15 Swara\]**

**Swara: For coding, not everyone knew how to code in python at the beginning of the season.** 

- Veteran members like Eli and Jacob taught newer members python

- Colin created a  python library of  code to make coding more efficient

- AND we commented on our code so that others understand and can edit it easily.


**\[slide 16 Matthew\]**  
 The team had to work through many problems throughout the season. For example….

* One problem was inconsistent runs. So we ….  
  Colin will explain more about the gyro and the battery.


**\[slide 17 Colin\]**  
**Colin:** We noticed at the qualifier that our bot’s behavior was very inconsistent. We suspected that it might have something to do with the bot’s battery, specifically that code written while the bot had a lower battery doesn’t run the same when the bot is fully charged. We then made a program that could take data on the bot’s battery as it drained. This data shows us that the battery is outputting more current, in a greater range, when it is charged than when it is in a more medium state of charge. Based on what we found, we have decided to run the bots down to about 90% battery before running or coding, as it is a much more stable current. Another thing we learned from this is that the bot’s batteries are not interchangeable, as they all have different health and recharge/discharge differently. We have also started taking data to see how the bot’s battery affects the gyro sensor.

**\[slide 18 Matthew\]**  
**Matthew:** Here are the things we do to share our work out  
For example:  
We hosted an FLL Explore Expo where 33 teams attended on January 25th

- And we help club students learn to code.

**CHANGE TO NEXT SLIDE**

- We advertise our library through the QR code which is also on our website


  
**\[Slide 19 (END)\]**

**Everyone**: *\*looking at the judges\** ***That’s a wrap — any questions?***

  **— — — — — — — — — — — — — — — — — — — — — — — — — — — —**  
***\*next page is code\****

**from hub import light\_matrix, motion\_sensor, port**  
**import motor\_pair**  
**import motor**  
**import runloop**

**import math**  
**import sys**

**print(sys.version)**

**\# Some constants for calculations**  
**d \= 5.5    \# Diameter of one wheel**  
**r \= 8      \# Radius of turning (using one wheel)**

**\# Takes distance in centimeters (cm), and stop (whether or not to stop moving after the instruction)**  
**async def forward(dist:float,stop:bool\=False,\*\*kwargs):**  
   **'''Move bot forwards by a number of centimeters.**

   **\- \`dist: float:\` The distance in centimeters**  
   **\- \`stop: bool:\` Controls whether or not motors will be issued a stop command at the end of the function.**  
   **\- \`\*\*kwargs: dict\[str, Unknown\]:\` Allows the user to pass acceleration/deceleration arguments optionally.**

   **Examples:**  
   **\`\`\`**  
       **forward(46)      \# Move forwards 46 centimeters**  
       **forward(-23)     \# Move backwards**  
       **forward(11,True) \# Move forwards and stop at the end**  
   **\`\`\`**  
   **'''**  
   **degrees \= dist\*(360.0/(math.pi\*d))**  
    
   **velocity \= kwargs.get("velocity",360)**  
   **if (degrees \< 0):**  
       **velocity \= \-1\*velocity**

   **time \= round((degrees/velocity)\*1000)**  
   **time \= abs(time)**

   **print('FORWARD: degrees:{degrees},time:{time}, velocity:{velocity}'.format(degrees=degrees,time=time,velocity=velocity)) \#Debug**

   **motor\_pair.move(motor\_pair.PAIR\_1,0,velocity=velocity,\*\*kwargs)**  
   **await runloop.sleep\_ms(time)**

   **if (stop \== True):**  
       **motor\_pair.stop(motor\_pair.PAIR\_1)**

**\# Takes angle of turn (theta), wheel (which wheel to turn with), and stop (whether or not to stop moving after the instruction)**  
**async def turn(pivot\_on:str,theta:int,stop:bool\=False,\*\*kwargs):**  
   **'''Turn bot by a number of degrees.**

   **\- \`pivot\_on: str:\` The wheel that the bot will pivot on.**  
   **\- \`theta: int:\` The angle that the bot will turn.**  
   **\- \`stop: bool:\` Controls whether or not motors will be issued a stop command at the end of the function.**  
   **\- \`\*\*kwargs: dict\[str, Unknown\]:\` Allows the user to pass acceleration/deceleration arguments optionally.**

   **Examples:**  
   **\`\`\`**  
       **turn("left",90)   \# Pivot by 90° on the left wheel**  
       **turn("left",-90)  \# Pivot back by 90° on the left wheel**  
       **turn("right",180) \# Pivot by 180° on the right wheel**  
   **\`\`\`**  
   **'''**  
    
   **motion\_sensor.reset\_yaw(0)**  
   **dist \= (2\*math.pi\*r)\*(theta/360.0)**  
   **degrees \= dist\*(360.0/(math.pi\*d))**

   **velocity \= kwargs.get("velocity",360)**  
   **if (degrees \< 0):**  
       **velocity \= \-1\*velocity**

   **print('TURN: wheel:{pivot\_on}, degrees:{degrees}, dist:{dist}, velocity:{velocity}'.format(pivot\_on=pivot\_on,degrees=degrees,dist=dist,velocity=velocity)) \#Debug**

   **if (pivot\_on \== "right"):**  
       **motor.stop(port.F,stop=1)**  
       **motor.run(port.C,velocity,\*\*kwargs)**  
       **if (theta \> 0):**  
           **while (motion\_sensor.tilt\_angles()\[0\] \< theta\*10):**  
               **await runloop.sleep\_ms(1)**  
       **elif (theta \< 0):**  
           **while (motion\_sensor.tilt\_angles()\[0\] \> theta\*10):**  
               **await runloop.sleep\_ms(1)**

   **elif (pivot\_on \== "left"):**  
       **motor.stop(port.C,stop=1)**  
       **motor.run(port.F,velocity,\*\*kwargs)**  
       **if (theta \> 0):**  
           **while (motion\_sensor.tilt\_angles()\[0\] \< theta\*10):**  
               **await runloop.sleep\_ms(1)**  
       **elif (theta \< 0):**  
           **while (motion\_sensor.tilt\_angles()\[0\] \> theta\*10):**  
               **await runloop.sleep\_ms(1)**

   **if (stop \== True):**  
       **motor.stop(port.C)**  
       **motor.stop(port.F)**

   **print('TURN ERROR:', theta\*10, ' ', motion\_sensor.tilt\_angles()\[0\], ' ', (motion\_sensor.tilt\_angles()\[0\]-theta\*10)/10)**  
   **motion\_sensor.reset\_yaw(0)**

**\# Example of what you could do using this code:**  
**async def main():**  
   **print("Hello World\! \-=- Welcome to the SuperSecretCode API")**  
   **motor\_pair.pair(motor\_pair.PAIR\_1,port.C,port.F)**  
   **await turn("left",90)**  
   **await turn("left",\-90)**  
   **await forward(20,True)**  
   **await forward(\-20)**  
   **await turn("right",\-90)**  
   **await turn("right",90,True)**

**runloop.run(main())**

* Why did you use colors to group missions?  
  * Jacob: we used colors to organize and keep track of missions in each group  
* How did you group missions together?  
  * Rishabh: We grouped missions together based on their difficulty and how close they were to each other.   
  * Prishita: Give an example and share how one attachment can help accomplish all missions  
* Who helped code missions?  
  * Panchami: We all helped code missions. Rishabh and Ei were the most experienced members of our team and helped everyone learn how to code.   
  * Yuhan: We assigned each team member to each group of missions. Rishabh and Eli went around to help team members solve any issues they encountered.   
* Why did you choose python to code your missions?  
  * Sasha: We chose python because it has more options and flexibility to control the robot.   
  * Prishita: Python helped us create a boilerplate code that was reusable. Once we knew that it worked, we were able to use it to program all our mission runs.  
* What was your most innovative attachment?’  
  * Audrey: Captain Hook because it helped us attempt multiple missions, it incorporated unique parts like lego rubber bands, and there were no motors used in this attachment, and it still helped us score 70 points using this attachment.  
* What is the boilerplate, how does it work/help with coding missions?  
* How did you choose what missions to do, and which not to do?  
* What is a PICK chart?  
* How did your team make sure everyone had an equal amount of work?

